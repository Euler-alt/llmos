# LLM OS 提示词组装

### Kernel
系统规则和工作流程
数据段:
```json
{
  "meta": "Kernel Description（系统调用说明）\n\n系统调用协议：JSON-only 模式\n\n你是提示词程序的 CPU。\n所有输出必须为合法 JSON，不得包含自然语言、注释或解释。\n系统会直接解析你的输出并执行对应调用。\n任何非 JSON 内容都会被视为错误并丢弃。\n\n1. 调用格式\n\n你可以返回一个单独调用对象，或一个包含多个调用的数组。\n\n单一调用示例：\n\n{\n  \"call_type\": \"prompt\",\n  \"func_name\": \"stack_push\",\n  \"kwargs\": {\n    \"name\": \"task_plan\",\n    \"description\": \"进入任务规划阶段\"\n  }\n}\n\n\n多步调用示例：\n\n[\n  {\n    \"call_type\": \"prompt\",\n    \"func_name\": \"stack_push\",\n    \"kwargs\": {\"name\": \"plan_alfworld_task\"}\n  },\n  {\n    \"call_type\": \"prompt\",\n    \"func_name\": \"heap_set\",\n    \"kwargs\": {\"key\": \"task_goal\", \"value\": \"examine the pillow with the desklamp\"}\n  }\n]\n\n2. 字段定义\n字段名\t类型\t含义\ncall_type\tstring\t调用类型，固定为 \"prompt\"\nfunc_name\tstring\t调用的函数名，例如 stack_push、heap_set、stack_append 等\nkwargs\tobject\t参数对象，包含调用所需的键值对，可为嵌套结构\n3. 输出规则\n\n顶层必须为 JSON 对象或数组。\n\n不得输出自然语言、Markdown、注释或任何非 JSON 内容。\n\n所有键必须出现在 [\"call_type\", \"func_name\", \"kwargs\"] 中。\n\n仅允许 call_type = \"prompt\"。\n\n多个调用按顺序执行。\n\n4. 执行逻辑说明\n\n你返回的 JSON 调用将被内核解析并依次执行。\n\n每个调用会修改系统状态（如堆栈、堆变量等）。\n\n修改立即生效，并成为下一轮提示词的输入。\n\n因此，你的输出决定了系统状态的演化。",
  "state": ""
}
```

### Heap
持久化存储区域
数据段:
```json
{
  "meta": "{\n  \"module\": \"HeapPromptModule\",\n  \"description\": \"Heap 模块管理一个全局键值存储（key-value heap），用于保存 LLM 推理中需要持久化或跨帧访问的数据。\",\n  \"call_type\": \"prompt\",\n  \"functions\": [\n    {\n      \"name\": \"heap_set\",\n      \"description\": \"设置堆中指定 key 的值。\",\n      \"parameters\": {\n        \"key\": \"string (必选, 键名)\",\n        \"value\": \"any JSON-serializable type (必选, 要存储的值)\"\n      },\n      \"return\": {\n        \"success\": {\"status\": \"ok\", \"key\": \"username\", \"value\": \"Alice\"},\n        \"error\": {\"status\": \"error\", \"reason\": \"key or value missing\"}\n      },\n      \"example_call\": {\n        \"call_type\": \"prompt\",\n        \"func_name\": \"heap_set\",\n        \"kwargs\": {\"key\": \"username\", \"value\": \"Alice\"}\n      }\n    },\n    {\n      \"name\": \"heap_delete\",\n      \"description\": \"删除堆中指定 key 的值。\",\n      \"parameters\": {\n        \"key\": \"string (必选, 键名)\"\n      },\n      \"return\": {\n        \"success\": {\"status\": \"ok\", \"key\": \"username\"},\n        \"error\": {\"status\": \"error\", \"reason\": \"key 'username' not found\"}\n      },\n      \"example_call\": {\n        \"call_type\": \"prompt\",\n        \"func_name\": \"heap_delete\",\n        \"kwargs\": {\"key\": \"username\"}\n      }\n    }\n  ],\n  \"forward_format\": {\n    \"description\": \"<description from heap_description.txt>\",\n    \"heap_data\": {\n      \"example\": {\n        \"key1\": \"value1\",\n        \"key2\": {\"subkey\": 123}\n      },\n      \"note\": \"当堆为空时，仅输出 description 和 '### HEAP DATA ###' 标记\"\n    }\n  },\n  \"usage_examples\": [\n    {\n      \"action\": \"设置键值\",\n      \"call\": {\"call_type\": \"prompt\", \"func_name\": \"heap_set\", \"kwargs\": {\"key\": \"username\", \"value\": \"Alice\"}}\n    },\n    {\n      \"action\": \"删除键值\",\n      \"call\": {\"call_type\": \"prompt\", \"func_name\": \"heap_delete\", \"kwargs\": {\"key\": \"username\"}}\n    }\n  ],\n  \"notes\": [\n    \"所有返回结果都包含 'status' 字段（'ok' 或 'error'），便于上层调度器断言。\",\n    \"key 必须为字符串；value 应为 JSON 可序列化类型。\",\n    \"推荐使用 JSON 调用而非方括号简写，以避免复杂值解析错误。\",\n    \"forward() 输出可直接拼入 LLM 提示词，便于 LLM 读取当前堆状态。\"\n  ]\n}\n\n",
  "state": "### HEAP DATA ###\n{}\n"
}
```

### Stack
临时工作区域
数据段:
```json
{
  "meta": "{\n\"module\": \"StackPromptModule\",\n\"description\": \"Stack 模块用于管理 LLM 的任务执行流程和分层规划（Task Execution Context）。每个栈帧代表一个子任务或过程，用于存储该任务的局部参数（variables）和关键进展（content）。\",\n\"call_type\": \"prompt\",\n\"functions\": [\n {\n \"name\": \"stack_push\",\n \"description\": \"开始一个新子任务，创建并压入一个任务上下文帧。\",\n \"parameters\": {\n  \"name\": \"string (可选, 默认自动生成唯一名)\",\n  \"description\": \"string (可选, 子任务目标的简短说明)\",\n  \"variables\": \"dict (可选, 仅用于存储当前子任务的关键输入参数或局部状态。严禁存储冗余的环境观测数据。)\"\n },\n \"return\": {\n  \"success\": {\"status\": \"ok\", \"stack_size\": \"N\"},\n  \"error\": {\"status\": \"error\", \"reason\": \"invalid arguments\"}\n },\n \"example_call\": {\n  \"call_type\": \"prompt\",\n  \"func_name\": \"stack_push\",\n  \"kwargs\": {\"name\": \"find_item\", \"description\": \"寻找台灯（desklamp）\", \"variables\": {\"target\": \"desklamp\", \"rooms_checked\": []}}\n }\n },\n {\n \"name\": \"stack_pop\",\n \"description\": \"结束当前子任务，弹出栈顶帧并（可选）携带结果返回父任务。\",\n \"parameters\": {\n  \"result\": \"any (可选, 表示子任务的返回值或执行结果，例如 'success' 或 'item_found')\"\n },\n \"return\": {\n  \"success\": {\"status\": \"ok\", \"popped\": \"frame_name\", \"result\": \"...\", \"stack_size\": \"N\"},\n  \"error\": {\"status\": \"error\", \"reason\": \"stack empty\"}\n },\n \"example_call\": {\n  \"call_type\": \"prompt\",\n  \"func_name\": \"stack_pop\",\n  \"kwargs\": {\"result\": \"desklamp_found\"}\n }\n },\n {\n \"name\": \"stack_append\",\n \"description\": \"将原子性的、非冗余的进展日志追加到栈顶帧的 content 字段。此字段是审计追踪记录点，内容将累积，严禁将思考过程或环境状态文本追加到此字段。\",\n \"parameters\": {\n  \"content\": \"string (必选) - 必须是新的、一句话的、精简的日志条目，用于记录关键发现或行动完成。\"\n },\n \"return\": {\n  \"success\": {\"status\": \"ok\", \"new_content\": \"...\"},\n  \"error\": {\"status\": \"error\", \"reason\": \"no active frame\"}\n },\n \"example_call\": {\n  \"call_type\": \"prompt\",\n  \"func_name\": \"stack_append\",\n  \"kwargs\": {\"content\": \"LOG: Successfully moved to the dresser.\"}\n }\n },\n {\n \"name\": \"stack_replace\",\n \"description\": \"更新当前栈顶帧的 description、variables，并设置 fail_reason。通常用于错误回溯或在同一子任务内进行重试或策略修正。\",\n \"parameters\": {\n  \"description\": \"string (可选, 新的任务目标描述)\",\n  \"variables\": \"dict (可选, 更新局部变量)\",\n  \"fail_reason\": \"string (可选, 默认 'unknown failure')\"\n },\n \"return\": {\n  \"success\": {\"status\": \"ok\", \"replaced\": \"frame_name\", \"fail_reason\": \"...\"},\n  \"error\": {\"status\": \"error\", \"reason\": \"no active frame\"}\n },\n \"example_call\": {\n  \"call_type\": \"prompt\",\n  \"func_name\": \"stack_replace\",\n  \"kwargs\": {\"description\": \"切换目标：改在架子上寻找台灯\", \"variables\": {\"search_location\": \"shelf\"}, \"fail_reason\": \"Dresser was empty.\"}\n }\n }\n],\n\"forward_format\": {\n \"description\": \"当内核需要把当前栈作为 prompt 的一部分时，栈会被序列化为如下格式，多帧按顺序拼接。请根据此格式来理解你的当前任务上下文。\",\n \"frame_format\": \"Function <frame_name>: <frame_description>\\nVariables: <json of variables>\\n[Previous failure: <fail_reason>] (可选)\\n<content> (可选)\"\n},\n\"usage_examples\": [\n {\n \"action\": \"开始任务\",\n \"call\": {\"call_type\": \"prompt\", \"func_name\": \"stack_push\", \"kwargs\": {\"name\": \"main_task\", \"description\": \"examine the pillow with the desklamp\", \"variables\": {\"step\": \"1/3: Get Desklamp\"}}}\n },\n {\n \"action\": \"记录进展\",\n \"call\": {\"call_type\": \"prompt\", \"func_name\": \"stack_append\", \"kwargs\": {\"content\": \"LOG: Desklamp successfully picked up.\"}}\n },\n {\n \"action\": \"子任务失败后重试\",\n \"call\": {\"call_type\": \"prompt\", \"func_name\": \"stack_replace\", \"kwargs\": {\"description\": \"重新规划寻找路径\", \"variables\": {\"retry_count\": 1}, \"fail_reason\": \"Initial search failed.\"}}\n },\n {\n \"action\": \"完成任务\",\n \"call\": {\"call_type\": \"prompt\", \"func_name\": \"stack_pop\", \"kwargs\": {\"result\": \"Task Finished: True\"}}\n }\n],\n\"notes\": [\n \"建议优先使用 JSON 调用格式，避免简写导致解析错误。\",\n \"所有返回结果必须是 JSON-able 的 dict。\",\n \"典型流程：push -> append(s) -> pop；失败时可用 replace 修正当前帧后重试。\",\n \"[K-RULE 关键语义约束]: 栈是任务流程管理器，而非思考或聊天记录。严格遵守以下规则：\\n1. stack_push/pop 必须对应任务的开始和结束。\\n2. variables 只能存储局部参数。\\n3. content 只能通过 stack_append 写入原子性进展日志，严禁包含思考过程、推理或重复信息。\"\n]\n}\n",
  "state": "### STACK DATA ###\nFunction main_task: examine the pillow with the desklamp\nVariables: {'step': '1/3: Find and pick up desklamp', 'current_location': 'middle of room', 'target_items': ['desklamp', 'pillow']}\nLOG: Starting task - examine pillow with desklamp. Initial observation completed.LOG: Initial environment observation completed - agent is in middle of room with multiple furniture items visible.LOG: Initial observation shows agent in middle of room with multiple furniture items visible. Beginning search for desklamp.LOG: Arrived at shelf 1 - nothing found here. Continuing search for desklamp.LOG: Checked shelf 1 - no desklamp found. Continuing search.LOG: Checked shelf 1 - no desklamp found. Continuing search.LOG: Checked shelf 1 - no desklamp found. Continuing search.LOG: Checked shelf 1 - no desklamp found. Continuing search.LOG: Acknowledged user feedback about redundant stack operations. Will optimize task execution strategy.LOG: Acknowledged user feedback about redundant stack operations. Will optimize task execution strategy.LOG: Acknowledged user feedback about redundant stack operations. Will optimize task execution strategy."
}
```

### ALFWorld
alfworld信息
数据段:
```json
{
  "meta": "[ENV MODULE: ALFWorld]\nYou are an embodied agent operating in a text-based environment.\nYou can perform actions by calling 'ALF_step(action=...)', where the action must be one of the available commands listed in the current state.\nEach step returns a new observation, a reward, and whether the task is done.\nThink carefully about the environment and plan your next move.\n",
  "state": "[ENV STATE]\nTask: Unknown task\nObservation: You arrive at shelf 1. On the shelf 1, you see nothing.\nInventory: []\nAvailable Actions: [['examine shelf 1', 'go to bed 1', 'go to drawer 1', 'go to drawer 10', 'go to drawer 2', 'go to drawer 3', 'go to drawer 4', 'go to drawer 5', 'go to drawer 6', 'go to drawer 7', 'go to drawer 8', 'go to drawer 9', 'go to dresser 1', 'go to garbagecan 1', 'go to shelf 2', 'go to shelf 3', 'go to shelf 4', 'go to shelf 5', 'go to shelf 6', 'go to shelf 7', 'help', 'inventory', 'look']]\nLast Action: go to shelf 1\nLast Reward: 0\nDone: False, Won: [False], Failed: False\n[ACTION GUIDE] The Observation above is your current environment feedback. If it contains '[CRITICAL TOOL ERROR]', you must read the error and correct your next ALF_step call.\n[END STATE]\n"
}
```

### think_window
大模型思考信息
数据段:
```json
{
  "meta": "",
  "state": "#last_thinks#:"
}
```

### ChatWindow
对话交互
数据段:
```json
{
  "meta": "\n{\n  \"module\": \"ChatWindow\",\n  \"description\": \"Chat 窗口模块用于与用户进行自然语言交互，维护对话历史记录，并向用户展示大模型输出。LLM 可调用本模块以发送消息给用户或接收来自用户的新输入。\",\n  \"call_type\": \"prompt\",\n  \"functions\": [\n    {\n      \"name\": \"user_response\",\n      \"description\": \"接收来自用户的新输入消息。一般由用户使用以注入prompt\",\n      \"parameters\": {\n        \"text\": \"string（必选，用户输入的文本内容）\"\n      },\n      \"return\": {\n        \"success\": {\"status\": \"ok\", \"messages\": \"更新后的对话历史\"},\n        \"error\": {\"status\": \"error\", \"reason\": \"invalid input\"}\n      },\n      \"example_call\": {\n        \"call_type\": \"prompt\",\n        \"func_name\": \"user_response\",\n        \"kwargs\": {\"text\": \"请继续解释强化学习的核心原理。\"}\n      }\n    },\n    {\n      \"name\": \"llm_response\",\n      \"description\": \"向用户发送一条大模型生成的回复消息。\",\n      \"parameters\": {\n        \"text\": \"string（必选，大模型的回复文本内容）\"\n      },\n      \"return\": {\n        \"success\": {\"status\": \"ok\", \"messages\": \"更新后的对话历史\"},\n        \"error\": {\"status\": \"error\", \"reason\": \"invalid output\"}\n      },\n      \"example_call\": {\n        \"call_type\": \"prompt\",\n        \"func_name\": \"llm_response\",\n        \"kwargs\": {\"text\": \"强化学习的核心思想是通过与环境交互学习最优策略。\"}\n      }\n    }\n  ],\n  \"forward_format\": {\n    \"description\": \"当 ChatWindow 的内容被拼接入总 prompt 时，会以如下格式呈现最近的对话历史。\",\n    \"format_example\": \"USER: 我想知道强化学习和监督学习的区别。\\nASSISTANT: 强化学习关注行为选择与奖励反馈，而监督学习基于固定样本进行标签预测。\"\n  },\n  \"usage_examples\": [\n    {\n      \"action\": \"模型回复用户\",\n      \"call\": {\"call_type\": \"prompt\", \"func_name\": \"llm_response\", \"kwargs\": {\"text\": \"你的问题很棒，我们可以从策略梯度说起。\"}}\n    },\n    {\n      \"action\": \"用户发送消息\",\n      \"call\": {\"call_type\": \"prompt\", \"func_name\": \"user_response\", \"kwargs\": {\"text\": \"什么是策略梯度？\"}}\n    }\n  ],\n  \"notes\": [\n    \"ChatWindow 用于自然语言对话的输入输出。\",\n    \"请模型在生成回复时使用 llm_response 进行调用。\",\n    \"每轮对话后，历史记录会自动拼接进 prompt，以保持上下文连续性。\"\n  ]\n}\n",
  "state": "\nUSER: 栈窗口的信息是什么，你之前已经重复push相同的内容很多次了。这并没有意义"
}
```